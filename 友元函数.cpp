友元函数
对类的私有对象而言，通常情况下，类的公有方法提供访问私有对象的成员的唯一访问路径。
但是也会有例外，即友元，友元有3种，分别是
友元函数 先讨论
友元类
友元成员函数

在为类重载二元运算符时（带两个参数的运算符），通常需要用到友元。
不是友元函数是，之前Time类中的 A=B*2.5; 
将被转化为 A=B.operator*(2.5);
这带来了一种限制，即类的对象必须是在左侧，左侧的操作数必须是调用对象
那么就不能处理A=2.5*B；这种情况

所以这种情况可采用友元函数来解决，它不由对象调用，它使用的所有值，包括对象，都是显式参数。
这样编译器能够将表达式A=2.5*B 与非成员函数相匹配 A=operator*（2.5，B）；
该函数的原型如下：
即Time operator*(double m, const Time & t);

友元函数声明方法
friend Time operator*(double m,const Time & t);

虽然operator*()函数是在类声明中声明的，但他不是成员函数，不能使用成员运算符.来调用
虽然operator*()函数不是成员函数，但它与成员函数的访问权限相同。

因为不是成员函数，所以在定义中不需要写Time:: 也不需要添加关键字friend

一句话总结，友元函数是非成员函数，但具有成员函数一样的访问权限。
那么友元函数是否有悖于面向对象编程的概念呢，不然，应该将友元函数看做类扩展接口的组成部分。类和友元只是表达类接口的两种不同机制。
友元并没有侵犯类对于对象的访问权限，因为只有类能声明哪一个函数是友元函数，所以类声明仍然是控制了访问。

常用的一个友元函数 重载<<运算符

cout<< trip; 显示一个类对象中数据成员的值
<<最初是左移运算符，ostream类对其进行了重载，将其转换为一个输出工具，对于每种基本类型，ostream类声明中都包含了相应的重载的operator<<()定义中不需要写Time
如果用Time类的成员函数来重载<<，Time对象将是第一个操作数，那么在使用<<时，必须是trip<<cout这种形式 
所以使用友元函数是一种解决方案
void operator<<(ostream & os,const Time &t)
{
	os<<t.hours<<t.minutes;
}

cout<<trip 使用cout对象本身，所以函数按引用来传递对象，这里os成为cout的一个别名，Time对象既可以按值传递，也可以按引用传递，因为这两种函数都能使函数使用对象的值。
按引用传递使用的内存和时间都比按值传递少。

链式
注意到上述函数的返回值为空，则表示不能连续输入cout<<trip<<travel
将返回值修改为返回ostream对象的一个引用
ostream& operator<<(ostream &os, const Time &t){
	os<<t.hours<<t.minutes;
	return os;
}
这意味着函数返回类型是ostream& ，是ostreamm对象的应用，函数的返回值就是传递给它的对象